**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `testnet`
- **Package ID:** `0x79b7453abe063fbc396bba3c125c9321fc2f3767af3884e4f2ca713c1c93c61d`
- **Module Name:** `calc`
- **Available Methods:**

  * `calculate` (constant: `CALCULATE`)

---

# **Move Contract: `contract/onchain_calculator/sources/onchain_calculator.move`**

```move
module onchain_calculator::calc {
use iota::object;
use iota::object::UID;
use iota::transfer;
use iota::tx_context;
const E_INVALID_OP: u64 = 1;
const E_UNDERFLOW: u64 = 2;
const E_DIV_BY_ZERO: u64 = 3;
public struct Calculation has key, store {
id: UID,
owner: address,
a: u64,
b: u64,
op: u8,
result: u64,
}
#[allow(lint(self_transfer))]
public fun calculate(a: u64, b: u64, op: u8, ctx: &mut tx_context::TxContext) {
let sender = tx_context::sender(ctx);
let result = compute(a, b, op);
let calc = Calculation {
id: object::new(ctx),
owner: sender,
a,
b,
op,
result,
};
transfer::public_transfer(calc, sender);
}
fun compute(a: u64, b: u64, op: u8): u64 {
if (op == 1) {
a + b
} else if (op == 2) {
assert!(a >= b, E_UNDERFLOW);
a - b
} else if (op == 3) {
a * b
} else if (op == 4) {
assert!(b > 0, E_DIV_BY_ZERO);
a / b
} else {
abort E_INVALID_OP
}
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
// hooks/useContract.ts
"use client"

/**
 * ============================================================================
 * IOTA ON-CHAIN CALCULATOR CONTRACT HOOK
 * ============================================================================
 */

import { useEffect, useState } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useIotaClientQuery,
  useSignAndExecuteTransaction,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import type { IotaObjectData } from "@iota/iota-sdk/client"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================

export const CONTRACT_MODULE = "calc"
export const CONTRACT_METHODS = {
  CALCULATE: "calculate",
} as const

// ðŸ‘‰ THAY Báº°NG PACKAGE ID THáº¬T SAU KHI DEPLOY
export const PACKAGE_ID = "0x79b7453abe063fbc396bba3c125c9321fc2f3767af3884e4f2ca713c1c93c61d"

// ============================================================================
// TYPES
// ============================================================================

export type OperatorSymbol = "+" | "-" | "Ã—" | "Ã·"

export interface CalculationInput {
  a: number
  b: number
  op: OperatorSymbol
}

export interface CalculationData {
  a: number
  b: number
  op: OperatorSymbol
  result: number
  owner: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  calculate: () => Promise<void>
  clearSession: () => void
}

// ============================================================================
// HELPERS
// ============================================================================

const opSymbolToCode: Record<OperatorSymbol, number> = {
  "+": 1,
  "-": 2,
  "Ã—": 3,
  "Ã·": 4,
}

const codeToOpSymbol = (code: number): OperatorSymbol => {
  switch (code) {
    case 1:
      return "+"
    case 2:
      return "-"
    case 3:
      return "Ã—"
    case 4:
      return "Ã·"
    default:
      return "+"
  }
}

// Extract fields from on-chain Calculation object
function getCalculationFields(data: IotaObjectData): CalculationData | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType)
    return null
  }

  const fields = data.content.fields as any
  if (!fields || fields.a == null || fields.b == null || fields.op == null || fields.result == null) {
    console.log("Missing fields in Calculation object")
    return null
  }

  // Resolve owner
  let owner = ""
  const rawOwner: any = (data as any).owner
  if (typeof rawOwner === "string") {
    owner = rawOwner
  } else if (rawOwner && typeof rawOwner === "object") {
    const v = Object.values(rawOwner)[0]
    owner = typeof v === "string" ? v : String(v ?? "")
  }

  if (!owner) {
    console.log("Owner not found on Calculation object")
    return null
  }

  const aNum = Number(fields.a)
  const bNum = Number(fields.b)
  const resultNum = Number(fields.result)
  const opSymbol = codeToOpSymbol(Number(fields.op))

  return {
    a: aNum,
    b: bNum,
    op: opSymbol,
    result: resultNum,
    owner,
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()

  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)
  const [input, setInput] = useState<CalculationInput>({
    a: 0,
    b: 0,
    op: "+",
  })

  // Load objectId from URL hash if any
  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  // Fetch latest Calculation object data
  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    { enabled: !!objectId }
  )

  const calcData: CalculationData | null = data?.data ? getCalculationFields(data.data) : null
  const objectExists = !!data?.data
  const hasValidData = !!calcData

  const calculate = async () => {
    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)

      const clampedA = Math.max(0, Math.floor(input.a))
      const clampedB = Math.max(0, Math.floor(input.b))
      const opCode = opSymbolToCode[input.op]

      const tx = new Transaction()
      tx.moveCall({
        target: `${PACKAGE_ID}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CALCULATE}`,
        arguments: [tx.pure.u64(clampedA), tx.pure.u64(clampedB), tx.pure.u8(opCode)],
      })

      signAndExecute(
        { transaction: tx as any },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })

              const created = effects?.created ?? []
              const calcObj = created.find((c: any) =>
                c.reference?.objectType?.endsWith("::Calculation")
              )
              const newObjectId = calcObj?.reference?.objectId

              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
                await refetch()
              } else {
                console.warn("No Calculation object found in transaction effects")
              }
            } catch (waitErr) {
              console.error("Error waiting for transaction:", waitErr)
            } finally {
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error calculate:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error building transaction:", err)
      setIsLoading(false)
    }
  }

  const clearSession = () => {
    setObjectId(null)
    setTransactionError(null)
    setHash(undefined)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const state: ContractState = {
    isLoading: isLoading || isFetching || isPending,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    input,
    setInput,
    data: calcData,
    objectId,
    objectExists,
    hasValidData,
    state,
    actions: {
      calculate,
      clearSession,
    } as ContractActions,
  }
}

export default useContract

```

---

# File 2: `components/sample.tsx`

```tsx
// components/sample.tsx
"use client"

/**
 * ============================================================================
 * IOTA ON-CHAIN CALCULATOR UI
 * ============================================================================
 */

import React, { ChangeEvent } from "react"
import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import { Button, Container, Flex, Heading, Text } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { input, setInput, data, state, actions, objectId, objectExists, hasValidData } =
    useContract()

  const isConnected = !!currentAccount

  const handleNumberChange =
    (field: "a" | "b") =>
    (e: ChangeEvent<HTMLInputElement>) => {
      const raw = e.target.value
      const num = raw === "" ? 0 : Number(raw)
      setInput((prev) => ({
        ...prev,
        [field]: Number.isNaN(num) ? 0 : num,
      }))
    }

  const handleOpChange = (e: ChangeEvent<HTMLSelectElement>) => {
    const op = e.target.value as typeof input.op
    setInput((prev) => ({ ...prev, op }))
  }

  if (!isConnected) {
    return (
      <div
        style={{
          minHeight: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "1rem",
        }}
      >
        <div style={{ maxWidth: "500px", width: "100%" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>
            IOTA On-chain Calculator dApp
          </Heading>
          <Text>Please connect your IOTA wallet to use the calculator.</Text>
        </div>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "100vh", padding: "1rem", background: "var(--gray-a2)" }}>
      <Container style={{ maxWidth: "900px", margin: "0 auto" }}>
        <Heading size="6" style={{ marginBottom: "2rem", textAlign: "center" }}>
          IOTA On-chain Calculator dApp
        </Heading>

        {/* Input panel */}
        <div
          style={{
            marginBottom: "1.5rem",
            padding: "1.5rem",
            background: "var(--gray-a3)",
            borderRadius: "12px",
          }}
        >
          <Text size="3" style={{ display: "block", marginBottom: "1rem" }}>
            Enter your calculation. The operation will be executed on-chain in a Move smart
            contract, and the result is stored as a Calculation object.
          </Text>

          <Flex gap="2" align="center" wrap="wrap">
            <input
              type="number"
              value={input.a}
              onChange={handleNumberChange("a")}
              style={{
                width: "120px",
                padding: "0.4rem 0.6rem",
                borderRadius: "6px",
                border: "1px solid var(--gray-a7)",
                background: "var(--gray-1)",
                color: "inherit",
              }}
            />

            <select
              value={input.op}
              onChange={handleOpChange}
              style={{
                padding: "0.4rem 0.6rem",
                borderRadius: "6px",
                border: "1px solid var(--gray-a7)",
                background: "var(--gray-1)",
                color: "inherit",
              }}
            >
              <option value="+">+</option>
              <option value="-">-</option>
              <option value="Ã—">Ã—</option>
              <option value="Ã·">Ã·</option>
            </select>

            <input
              type="number"
              value={input.b}
              onChange={handleNumberChange("b")}
              style={{
                width: "120px",
                padding: "0.4rem 0.6rem",
                borderRadius: "6px",
                border: "1px solid var(--gray-a7)",
                background: "var(--gray-1)",
                color: "inherit",
              }}
            />

            <Button
              size="3"
              onClick={actions.calculate}
              disabled={state.isLoading || state.isPending}
            >
              {state.isLoading || state.isPending ? (
                <>
                  <ClipLoader size={16} style={{ marginRight: "8px" }} />
                  Calculating...
                </>
              ) : (
                "Calculate on-chain"
              )}
            </Button>
          </Flex>

          {state.error && (
            <div
              style={{
                marginTop: "1rem",
                padding: "1rem",
                background: "var(--red-a3)",
                borderRadius: "8px",
              }}
            >
              <Text style={{ color: "var(--red-11)" }}>
                Error: {(state.error as Error)?.message || String(state.error)}
              </Text>
            </div>
          )}
        </div>

        {/* Result panel */}
        {objectId && (
          <div>
            {state.isLoading && !data ? (
              <Text>Loading calculation result...</Text>
            ) : state.error ? null : objectExists && !hasValidData ? (
              <div
                style={{
                  padding: "1rem",
                  background: "var(--yellow-a3)",
                  borderRadius: "8px",
                }}
              >
                <Text style={{ color: "var(--yellow-11)" }}>
                  Calculation object found but structure is invalid. Please verify the
                  contract.
                </Text>
                <Text
                  size="1"
                  style={{
                    color: "var(--gray-a11)",
                    marginTop: "0.5rem",
                    display: "block",
                  }}
                >
                  Calculation ID: {objectId}
                </Text>
              </div>
            ) : data ? (
              <div>
                <div
                  style={{
                    marginBottom: "1rem",
                    padding: "1.5rem",
                    background: "var(--gray-a3)",
                    borderRadius: "12px",
                    textAlign: "center",
                  }}
                >
                  <Text size="2" style={{ display: "block", marginBottom: "0.5rem" }}>
                    Result
                  </Text>
                  <Heading size="7" style={{ marginBottom: "0.5rem" }}>
                    {data.a} {data.op} {data.b} = {data.result}
                  </Heading>
                  <Text
                    size="1"
                    style={{
                      color: "var(--gray-a11)",
                      display: "block",
                    }}
                  >
                    Calculation ID: {objectId}
                  </Text>
                  <Text
                    size="1"
                    style={{
                      color: "var(--gray-a11)",
                      display: "block",
                      marginTop: "0.25rem",
                    }}
                  >
                    Owner: {data.owner}
                  </Text>
                </div>

                {state.hash && (
                  <div
                    style={{
                      marginTop: "0.5rem",
                      padding: "1rem",
                      background: "var(--gray-a3)",
                      borderRadius: "8px",
                    }}
                  >
                    <Text size="1" style={{ display: "block", marginBottom: "0.5rem" }}>
                      Last Transaction Hash
                    </Text>
                    <Text
                      size="2"
                      style={{ fontFamily: "monospace", wordBreak: "break-all" }}
                    >
                      {state.hash}
                    </Text>
                    {state.isConfirmed && (
                      <Text
                        size="2"
                        style={{
                          color: "green",
                          marginTop: "0.5rem",
                          display: "block",
                        }}
                      >
                        Transaction confirmed!
                      </Text>
                    )}
                  </div>
                )}

                <Button
                  variant="soft"
                  size="2"
                  onClick={actions.clearSession}
                  style={{ marginTop: "1rem" }}
                  disabled={state.isLoading || state.isPending}
                >
                  Clear Session
                </Button>
              </div>
            ) : null}
          </div>
        )}
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x79b7453abe063fbc396bba3c125c9321fc2f3767af3884e4f2ca713c1c93c61d` and Module: `calc`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
